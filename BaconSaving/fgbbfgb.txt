self.load_stl_button = Button(self.window,text="Load STL",command = self.load_stl)
    self.load_stl_button.place(x=420,y=340)
    self.load_stl_button = Button(self.window,text="Extrapolate wing from STL", command = self.Extrapolate_STL)
    self.load_stl_button.place(x=490,y=340)


def Extrapolate_STL(self):
      self.root_plane, self.tip_plane = self.detect_planes()
      #self.tip_plane = self.order_points(self.tip_plane)
      #self.root_plane = self.order_points(self.root_plane)
      #for ele in self.tip_plane:
          #print(ele)
      self.tip_plane = self.find_start_reorder(self.tip_plane)

      plt.plot(self.tip_plane[:,0],self.tip_plane[:,1],color='green')
      plt.scatter(self.tip_plane[0,0],self.tip_plane[0,1],color='red')
      plt.show()

  def resample_and_match(self,array,n):
      self.sampling_step = len(array)/n
  def find_start_reorder(self,array):
      self.joint_tightness = zeros(array.shape[0])
      for self.index in range(0,array.shape[0]):
          if self.index+1>=self.joint_tightness.shape[0]:
              self.old_point_vector = array[self.index-1]-array[self.index]
              self.new_point_vector = array[self.index]-array[0]
          else:
              self.old_point_vector = array[self.index-1]-array[self.index]
              self.new_point_vector = array[self.index]-array[self.index+1]
          self.joint_tightness[self.index]=absolute(arctan2(self.old_point_vector[0],self.old_point_vector[1])-arctan2(self.new_point_vector[0],self.new_point_vector[1]))
      array = roll(array,-argmax(self.joint_tightness),axis=0)
      return array


  def order_points(self,array):
      '''First filtering pass'''
      self.uarray = unique(array,axis=0) #Filters out duplicate points
      self.centre_point = mean(self.uarray,axis=0) #finds centre point
      self.offset_points = self.uarray-self.centre_point # offsets points so that mean is at 0,0
      self.ordered_points = sorted(self.offset_points,key=lambda x: arctan2(x[1],x[0]))+self.centre_point #computed angles to points and sorts according to angle
      self.ordered_points = self.find_start_reorder(self.ordered_points)
      '''Second fintering pass'''
      print(self.ordered_points)
      self.reordered_points = []
      self.poi = self.ordered_points[0]
      self.reordered_points.append(self.poi)
      print(self.ordered_points)
      self.ordered_points = self.ordered_points[1:]
      print(self.ordered_points)
      self.offset_points = self.ordered_points-self.poi
      self.dist = hypot(self.offset_points[:,0],self.offset_points[:,1])
      self.sorting_vector = self.ordered_points[argmin(self.dist[self.dist!=0])]-self.poi
      self.sorting_vector_angle = arctan2(self.sorting_vector[1],self.sorting_vector[0])
      print("sorting angle",min(self.dist),self.sorting_vector,self.sorting_vector_angle)


      for i in range(self.ordered_points.shape[0]):
          pass








      return self.ordered_points

      '''

      '''
  def detect_planes(self):
      self.plane_axis_weighting = [0,0,0]
      self.stl_sampling_index = choice(int(self.stl_mesh.shape[0]),int(0.2*self.stl_mesh.shape[0]))
      self.stl_sampling = array([self.stl_mesh[self.index] for self.index in self.stl_sampling_index])
      self.loading_label = Label(self.window,text="Loading... Please Wait")
      self.loading_label.place(x=420,y=380)
      self.progbar = Progressbar(self.window, orient=HORIZONTAL, length=200, mode='determinate')
      self.progbar.place(x=420,y=370)
      self.progstep = 200/self.stl_sampling.shape[0]
      for self.point_a in self.stl_sampling:
          self.window.update_idletasks()
          self.progbar['value']+=self.progstep
          for self.point_b in self.stl_sampling:
              self.comp = equal(self.point_a[0][0],self.point_b[0][0])
              if self.comp[0]==True:
                  self.plane_axis_weighting[0]+=1
              if self.comp[1]==True:
                  self.plane_axis_weighting[1]+=1
              if self.comp[2]==True:
                  self.plane_axis_weighting[2]+=1
          print(self.plane_axis_weighting)
      self.loading_label.destroy()
      self.progbar.destroy()
      self.plane_index = argmax(self.plane_axis_weighting)
      print(self.plane_index)

      self.filtered = []
      for self.line in self.stl_mesh
      self.plane_points = self.raw_stl_points[:,self.plane_index]
      self.planes = unique(self.plane_points)
      self.tip_offset = 0
      self.root_offset = self.planes.max()
      self.tip_profile = delete(array([self.stl_point for self.stl_point in self.raw_stl_points if self.stl_point[self.plane_index]==self.tip_offset]),self.plane_index,1)
      self.root_profile = delete(array([self.stl_point for self.stl_point in self.raw_stl_points if self.stl_point[self.plane_index]==self.root_offset]),self.plane_index,1)
      return self.root_profile, self.tip_profile


      print(len(self.tip_profile),len(self.root_profile))
  def render_stl(self):
      self.theta_a += 0.0
      self.theta_b += 0.0
      self.theta_g += 0.0
      self.rotation_matrix = array([[cos(self.theta_a)*cos(self.theta_b), cos(self.theta_a)*sin(self.theta_b)*sin(self.theta_g)-sin(self.theta_a)*cos(self.theta_g), cos(self.theta_a)*sin(self.theta_b)*cos(self.theta_g)+sin(self.theta_a)*sin(self.theta_g)],
                                    [sin(self.theta_a)*cos(self.theta_b), sin(self.theta_a)*sin(self.theta_b)*sin(self.theta_g)+cos(self.theta_a)*cos(self.theta_g), sin(self.theta_a)*sin(self.theta_b)*cos(self.theta_g)-cos(self.theta_a)*sin(self.theta_g)],
                                    [-sin(self.theta_b), cos(self.theta_b)*sin(self.theta_g), cos(self.theta_b)*cos(self.theta_g)]])
      self.points = self.raw_stl_points - self.raw_stl_points.min(axis=0)
      self.points = self.points/max(self.points.max(axis=0))
      self.projection_model = self.points - self.points.max(axis=0)/2
      self.projection_model = matmul(self.projection_model, self.rotation_matrix)
      self.display_model = self.projection_model + [0,0,2]
      self.ders = self.display_model[:]/self.display_model[:,2].reshape(self.display_model.shape[0],1)
      self.projection  = self.ders[:,0:2]*array([200,300])
      self.projection +=array([200,350])
      self.img = zeros((300,700,3))
      for self.pix in self.projection:
          try:
              self.img[int(self.pix[0]),int(self.pix[1])] = [255,255,255]
          except:
              pass
      self.canvas_img = ImageTk.PhotoImage(image=Image.fromarray(array(self.img).astype(uint8)))
      self.stl_canvas.create_image(150,150,image = self.canvas_img)
      self.stl_canvas.after(100,self.render_stl)



      def load_stl(self):
            self.wing_stl_address = filedialog.askopenfilename()
            self.wing_mesh = mesh.Mesh.from_file(self.wing_stl_address)
            self.stl_mesh = []
            for self.index in range(self.wing_mesh.points.shape[0]):
                self.stl_mesh.append(array([array([array(self.wing_mesh.points[self.index][0:3]),array(self.wing_mesh.points[self.index][3:6])]),array(self.wing_mesh.points[self.index][3:6]-self.wing_mesh.points[self.index][0:3])  ]))
                self.stl_mesh.append(array([array([array(self.wing_mesh.points[self.index][3:6]),array(self.wing_mesh.points[self.index][6:9])]),array(self.wing_mesh.points[self.index][6:9]-self.wing_mesh.points[self.index][3:6])  ]))
                self.stl_mesh.append(array([array([array(self.wing_mesh.points[self.index][6:9]),array(self.wing_mesh.points[self.index][0:3])]),array(self.wing_mesh.points[self.index][0:3]-self.wing_mesh.points[self.index][6:9])  ]))
            self.stl_mesh = array(self.stl_mesh)
            print(self.stl_mesh[0])

            #list(map(lambda x:print(x),self.stl_mesh))

            #self.stl_canvas.after(100,self.render_stl)

            self.stl_canvas = Canvas(self.window, width = 700, height = 300)
                self.stl_canvas.place(x=420,y=390)
